@model DayzlightWebapp.Models.LivemapModel
@{
    System.Threading.Thread.CurrentThread.CurrentCulture = System.Globalization.CultureInfo.InvariantCulture;
}

<div id="map-div" class="div-map">
    <canvas id="map-canvas"></canvas>
</div>
<div id="timeline-div" class="div-timeline">
    <canvas id="timeline-canvas"></canvas>
</div>
<script>
    var timePoints = [
    @foreach(var tp in Model.Timepoints)
    {
    @:{
    @:    TimePoint: "@Html.Raw(tp.TimePoint.ToString("o"))",
    @:    PlayerMovements: [
          foreach(var plmov in tp.PlayerMovements)
          {
    @:        {
    @:            PosX: @Html.Raw(plmov.PosX),
    @:            PosY: @Html.Raw(plmov.PosY),
    @:            Dir: @Html.Raw(plmov.Dir),
    @:            Name: "@Html.Raw(plmov.PlayerName.Name)",
    @:            Uid: "@Html.Raw(plmov.PlayerName.PlayerInfo.Uid)",
    @:            Color: "#@Html.Raw(plmov.PlayerName.PlayerInfo.Color)"
    @:        },
          }
    @:    ]
    @:},
    }
    ];
    var currentTimePointId = timePoints.length - 1;
    var updateMap;

    Math.radians = function (degrees) {
        return degrees * Math.PI / 180;
    }

    function trackTransforms(ctx) {
        var svg = document.createElementNS("http://www.w3.org/2000/svg", 'svg');
        var xform = svg.createSVGMatrix();
        ctx.getTransform = function () { return xform; };

        var savedTransforms = [];
        var save = ctx.save;
        ctx.save = function () {
            savedTransforms.push(xform.translate(0, 0));
            return save.call(ctx);
        };

        var restore = ctx.restore;
        ctx.restore = function () {
            xform = savedTransforms.pop();
            return restore.call(ctx);
        };

        var scale = ctx.scale;
        ctx.scale = function (sx, sy) {
            xform = xform.scaleNonUniform(sx, sy);
            return scale.call(ctx, sx, sy);
        };

        var rotate = ctx.rotate;
        ctx.rotate = function (radians) {
            xform = xform.rotate(radians * 180 / Math.PI);
            return rotate.call(ctx, radians);
        };

        var translate = ctx.translate;
        ctx.translate = function (dx, dy) {
            xform = xform.translate(dx, dy);
            return translate.call(ctx, dx, dy);
        };

        var transform = ctx.transform;
        ctx.transform = function (a, b, c, d, e, f) {
            var m2 = svg.createSVGMatrix();
            m2.a = a; m2.b = b; m2.c = c; m2.d = d; m2.e = e; m2.f = f;
            xform = xform.multiply(m2);
            return transform.call(ctx, a, b, c, d, e, f);
        };

        var setTransform = ctx.setTransform;
        ctx.setTransform = function (a, b, c, d, e, f) {
            xform.a = a;
            xform.b = b;
            xform.c = c;
            xform.d = d;
            xform.e = e;
            xform.f = f;
            return setTransform.call(ctx, a, b, c, d, e, f);
        };

        var pt = svg.createSVGPoint();
        ctx.transformedPoint = function (x, y) {
            pt.x = x; pt.y = y;
            return pt.matrixTransform(xform.inverse());
        }
    };

    function mapProcessing() {
        var canvas = document.getElementById("map-canvas");
        var mapimg = new Image;
        var mapwidth = @Html.Raw(Model.ServerInfo.MaxCornerX - Model.ServerInfo.MinCornerX);
        var mapheight = @Html.Raw(Model.ServerInfo.MaxCornerY - Model.ServerInfo.MinCornerY);
        mapimg.src = '@Html.Raw("/Content/Maps/" + Model.ServerInfo.WorldName + "/map.png")';
        window.addEventListener("load", function () {
            var ctx = canvas.getContext('2d');
            trackTransforms(ctx);

            var redraw = updateMap = function () {
                // Clear the entire canvas
                var p1 = ctx.transformedPoint(0, 0);
                var p2 = ctx.transformedPoint(canvas.width, canvas.height);
                ctx.clearRect(p1.x, p1.y, p2.x - p1.x, p2.y - p1.y);

                ctx.save();
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.restore();

                ctx.drawImage(mapimg, 0, 0, mapwidth, mapheight);

                var trailSize = 10;
                if (currentTimePointId >= 0) {
                    var drawCount = 0;
                    for (var drawId = currentTimePointId - trailSize < 0 ? 0 : currentTimePointId - trailSize;
                        drawId <= currentTimePointId; drawId++) {
                        drawCount++;
                        timePoints[drawId].PlayerMovements.forEach(function(plmov) {
                            var rad = (p2.x - Math.max(0, p1.x)) / (canvas.width * 0.15);
                            var x = plmov.PosX;
                            var y = mapheight - plmov.PosY;
                            var dir = plmov.Dir + 180;
                            var ang = 30;
                            var linew = Math.min(rad / 2, Math.max(1, (rad / 2)));

                            ctx.fillStyle = ctx.strokeStyle = plmov.Color;
                            if (drawId > currentTimePointId - trailSize && timePoints[drawId - 1]) {
                                var last = timePoints[drawId - 1].PlayerMovements.find(function (x) {
                                    return x.Uid === plmov.Uid
                                });
                                
                                if (last) {
                                    ctx.lineWidth = linew;
                                    ctx.beginPath();
                                    ctx.moveTo(x, y);
                                    ctx.lineTo(last.PosX, mapheight - last.PosY);
                                    ctx.stroke();
                                    ctx.lineWidth = 1;
                                }
                            }

                            if (currentTimePointId == drawId) {
                                ctx.beginPath();
                                ctx.arc(x, y, rad, 0, 2 * Math.PI);
                                ctx.fill();

                                ctx.beginPath();
                                ctx.moveTo(
                                    x - (Math.sin(Math.radians(dir - ang)) * rad),
                                    y + (Math.cos(Math.radians(dir - ang)) * rad)
                                );
                                ctx.lineTo(
                                    x - (Math.sin(Math.radians(dir)) * (rad * 1.4)),
                                    y + (Math.cos(Math.radians(dir)) * (rad * 1.4))
                                );
                                ctx.lineTo(
                                    x - (Math.sin(Math.radians(dir + ang)) * rad),
                                    y + (Math.cos(Math.radians(dir + ang)) * rad)
                                );
                                ctx.closePath();
                                ctx.fill();

                                ctx.font = (rad * 1.6) + "px Helvetica, Arial, sans-serif";
                                ctx.fillText(plmov.Name, x + rad, y - rad);
                            }
                            else {
                                ctx.beginPath();
                                ctx.arc(x, y, linew * 0.75, 0, 2 * Math.PI);
                                ctx.fill();
                            }
                        });
                    }
                }
            }

            var processResize = function () {
                canvas.width = $("#map-div").innerWidth();
                canvas.height = $("#map-div").innerHeight();
            }

            canvas.addEventListener('resize', function () {
                processResize();
                redraw();
            }, false);

            var fixTranlation = function () {
                var fixmin = ctx.transformedPoint(0, 0);
                if (fixmin.x < 0) {
                    ctx.translate(fixmin.x, 0);
                }
                if (fixmin.y < 0) {
                    ctx.translate(0, fixmin.y);
                }

                var fixmax = ctx.transformedPoint(canvas.width, canvas.height);
                if (fixmax.x > mapwidth) {
                    ctx.translate((fixmax.x - mapwidth), 0);
                }

                if (fixmax.y > mapheight) {
                    ctx.translate(0, (fixmax.y - mapheight));
                }
            }

            processResize();
            var dragStart;
            var lastX = canvas.width / 2, lastY = canvas.height / 2;
            ctx.translate(-(mapwidth / 2), -(mapheight / 2));
            ctx.scale(0.25, 0.25);
            fixTranlation();
            redraw();

            canvas.addEventListener('mousedown', function (evt) {
                document.body.style.mozUserSelect = document.body.style.webkitUserSelect = document.body.style.userSelect = 'none';
                lastX = evt.offsetX || (evt.pageX - canvas.offsetLeft);
                lastY = evt.offsetY || (evt.pageY - canvas.offsetTop);
                dragStart = ctx.transformedPoint(lastX, lastY);
            }, false);

            canvas.addEventListener('mousemove', function (evt) {
                lastX = evt.offsetX || (evt.pageX - canvas.offsetLeft);
                lastY = evt.offsetY || (evt.pageY - canvas.offsetTop);
                if (dragStart) {
                    var pt = ctx.transformedPoint(lastX, lastY);
                    ctx.translate(pt.x - dragStart.x, pt.y - dragStart.y);
                    fixTranlation();
                    redraw();
                }
            }, false);

            canvas.addEventListener('mouseup', function (evt) {
                dragStart = null;
            }, false);

            var scaleFactor = 1.05;
            var zoom = function (clicks) {
                var pt = ctx.transformedPoint(lastX, lastY);
                var min = ctx.transformedPoint(0, 0);
                var max = ctx.transformedPoint(canvas.width, canvas.height);
                var factor = Math.pow(scaleFactor, clicks);

                var needScale = false;
                if (factor > 1) {
                    if (max.x - Math.max(0, min.x) > 1000 &&
                        max.y - Math.max(0, min.y) > 1000) {
                        needScale = true;
                    }
                }
                else if (factor < 1) {
                    if ((max.x - Math.max(0, min.x)) / factor < mapwidth &&
                        (max.y - Math.max(0, min.y)) / factor < mapheight) {
                        needScale = true;
                    }
                }

                if (needScale) {
                    ctx.translate(pt.x, pt.y);
                    ctx.scale(factor, factor);
                    ctx.translate(-pt.x, -pt.y);
                }

                fixTranlation();
                redraw();
            }

            var handleScroll = function (evt) {
                var delta = evt.wheelDelta ? evt.wheelDelta / 40 : evt.detail ? -evt.detail : 0;
                if (delta) zoom(delta);
                return evt.preventDefault() && false;
            };

            canvas.addEventListener('DOMMouseScroll', handleScroll, false);
            canvas.addEventListener('mousewheel', handleScroll, false);
        }, false);
    };

    function timelineProcessing() {
        var step = 10;
        var canvas = document.getElementById("timeline-canvas");
        window.addEventListener("load", function () {
            var ctx = canvas.getContext('2d');
            trackTransforms(ctx);

            var redraw = function () {
                // Clear the entire canvas
                var p1 = ctx.transformedPoint(0, 0);
                var p2 = ctx.transformedPoint(canvas.width, canvas.height);
                ctx.clearRect(p1.x, p1.y, p2.x - p1.x, p2.y - p1.y);

                ctx.save();
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.fillStyle = $(".navbar").css("background-color");
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.restore();

                // Draw timeline
                ctx.fillStyle = "#2C6330";
                var i = 0;
                timePoints.forEach(function (tp) {
                    var divider = 1.1;
                    if (i % 5 == 0) { divider = 1.4; }
                    if (i % 10 == 0) { divider = 1.8; }
                    if (i == timePoints.length - 1) {
                        divider = 1.8;
                        ctx.fillStyle = "#2C6330";
                    }
                    ctx.fillRect(i * step, canvas.height / divider, 1, canvas.height);
                    ctx.fillStyle = "#999999";
                    i++;
                });

                // Draw carret
                var carret = ctx.transformedPoint(canvas.width / 2, 0);
                var pointId = Math.floor(carret.x / step);
                var newTimePointId = pointId < 0
                    ? 0
                    : timePoints[pointId]
                        ? pointId
                        : timePoints.length - 1;

                if (newTimePointId != currentTimePointId) {
                    currentTimePointId = newTimePointId;
                    updateMap();
                }

                ctx.fillStyle = "#D62727";
                ctx.font = "12px Helvetica, Arial, sans-serif";
                ctx.fillRect(carret.x, 0, 2, canvas.height);
                if (currentTimePointId >= 0) {
                    var date = new Date(Date.parse(timePoints[currentTimePointId].TimePoint));
                    var date_utc = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds()));
                    ctx.fillText(date_utc.toLocaleTimeString(), carret.x + 4, 14);
                }
            }

            var processResize = function () {
                canvas.width = $("#timeline-div").innerWidth();
                canvas.height = $("#timeline-div").innerHeight();
            }

            canvas.addEventListener('resize', function () {
                processResize();
                redraw();
            }, false);

            processResize();
            ctx.translate((canvas.width / 2) - ((timePoints.length - 1) * 10), 0);
            redraw();

            var dragStart;
            var lastX = 0;
            canvas.addEventListener('mousedown', function (evt) {
                document.body.style.mozUserSelect = document.body.style.webkitUserSelect = document.body.style.userSelect = 'none';
                lastX = evt.offsetX || (evt.pageX - canvas.offsetLeft);
                dragStart = ctx.transformedPoint(lastX, 0);
            }, false);

            canvas.addEventListener('mousemove', function (evt) {
                lastX = evt.offsetX || (evt.pageX - canvas.offsetLeft);
                if (dragStart) {
                    var pt = ctx.transformedPoint(lastX, 0);
                    ctx.translate(pt.x - dragStart.x, 0);
                    redraw();
                }
            }, false);

            canvas.addEventListener('mouseup', function (evt) {
                dragStart = null;
            }, false);

            var scaleFactor = 25;
            var zoom = function (clicks) {
                var pt = ctx.transformedPoint(lastX, 0);
                var factor = clicks * scaleFactor;
                ctx.translate(factor, 0);
                redraw();
            }

            var handleScroll = function (evt) {
                var delta = evt.wheelDelta ? evt.wheelDelta / 40 : evt.detail ? -evt.detail : 0;
                if (delta) zoom(delta);
                return evt.preventDefault() && false;
            };

            canvas.addEventListener('DOMMouseScroll', handleScroll, false);
            canvas.addEventListener('mousewheel', handleScroll, false);
        }, false);
    };

    timelineProcessing();
    mapProcessing();
</script>
